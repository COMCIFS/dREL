# pytest will run this file automatically.
# Test the autogenerated dREL parser against various dREL
# fragments.

import pytest
from lark import Lark
from CifFile import CifDic, CifFile
from py_transformer import TreeToPy, CategoryObject, Packet, ExecBlock
import re,math

# Constants
grammar_file = "lark_grammar.ebnf"
dic_file = "/home/jrh/COMCIFS/cif_core/cif_core.dic"

frag_collection = {}

frag_collection["assign"] = "_a = 0"
frag_collection["brackets"] = """With c as return
 
    return.value = Acosd(
    (Cosd(c.angle_beta)*Cosd(c.angle_gamma)-Cosd(c.angle_alpha))/(Sind(c.angle_beta)*Sind(c.angle_gamma)))"""

frag_collection["matrix"] = """
          a = 11 b = 12 c = -5.4
          return.val =  [[a,b,c],
                                               [1,2,3],
                                               ['a','b','c']]
"""
frag_collection["simple_index"] = """
    c = [1,2,3,4]
    return.val  =  c[0]+ c[3]
                       
"""
frag_collection["call_suite"] = """
   If(setting == 'triclinic') {
      If( Abs(a-b)<d || Abs(a-c)<d || Abs(b-c)<d )          Alert('B', warn_len)
      If( Abs(alp-90)<d || Abs(bet-90)<d || Abs(gam-90)<d ) Alert('B', warn_ang)
      }
"""
frag_collection["ifelse"] = """
   a = 1 b =2 c = 3
   if (a == 3) r = 1
   else if (a == 2) r = 4
   else if (c == 11) r = 5
   else if (a == 1) r = 2
   else r == 6
   return.val = r
"""
frag_collection["indices"] = """
         sm =  matrix([[1.0,0.0,0.0,0.5],
                [0.0,1.0,0.0,0.5],
                [0.0,0.0,1.0,0.5],
                [0.0,0.0,0.0,1.0]])
 
        return.val =  [[sm[0,0],sm[0,1],sm[0,2]],
                              [sm[1,0],sm[1,1],sm[1,2]],
                              [sm[2,0],sm[2,1],sm[2,2]]]
"""
# 
@pytest.fixture
def lark_grammar(request,scope="module"):
    grammar_file = getattr(request.module,"grammar_file")
    grammar = open(grammar_file).read()
    parser = Lark(grammar,start="input",parser="lalr",lexer="contextual")
    return parser

@pytest.fixture
def load_cifdic(request,scope="module"):
    cifdic = getattr(request.module,"dic_file")
    return CifDic(cifdic,do_imports='Contents',do_dREL=False)

@pytest.fixture
def drel_methods(request,scope="module"):
    p = load_cifdic(request, scope)
    has_meth = list([n for n in p.keys() if '_method.expression' in p[n]])
    has_meth.sort()
    return [(n,p[n]['_method.expression']) for n in has_meth]

@pytest.fixture
def prep_methods(request,scope="module"):
    meths = drel_methods(request,scope)
    for mn,(name,one_m) in enumerate(drel_methods):
        for n,om in enumerate(one_m):   #multiple methods possible
            print("=== %s(%d) ===" % (name,mn))
            print(om)
            tokens = lark_grammar.lex(om+"\n")
            #for t in tokens:
            #    print(repr(t))
            tree = lark_grammar.parse(om+"\n")
            #print(tree.pretty())

@pytest.fixture
def pytransformer(request,scope="module"):
    tt = TreeToPy("return.val","myfunc",
                  {"return.val":{"_definition.id":'return.val',
                                 "_definition.class":"Datum",
                                 "_name.category_id":"return",
                                 "_name.object_id":"val"},
                   "return":{"_definition.id":'return',
                             "_definition.class":"Set",
                             "_name.category_id":"Top"}}
                  )
    return tt

@pytest.fixture
def getdata(request,scope="module"):
    d = CifFile("nick1.cif",grammar="STAR2")
    return d.first_block()

@pytest.fixture
def getexecdata(request):
    """Get an executable data block with pre-prepared functions"""
    d = CifFile("nick1.cif",grammar="STAR2")
    dic = load_cifdic(request,scope="module")
    grammar_file = getattr(request.module,"grammar_file")
    return ExecBlock(d.first_block(),dic,grammar_file)

@pytest.fixture
def load_funcs(request,scope="module"):
    """Prepare all drel functions"""
    p = load_cifdic(request,scope)
    parser = lark_grammar(request,scope)
    func_meths = [f for f in p.keys() if p[f].get('_name.category_id')=='function']
    func_meths = [(f,p[f]['_method.expression'][0]) for f in func_meths]
    # now prepare them all
    processed = [process_a_phrase(f[1],parser,TreeToPy(f[0],"",p))[0] for f in func_meths]
    return processed

def process_a_phrase(phrase,parser,transformer=None):
    print("========")
    print(phrase)
    #print("Tokens:")
    tokens = parser.lex(phrase)
    tree = parser.parse(phrase,debug=False)
    #print(tree.pretty())
    if transformer is not None:
        x = transformer.transform(tree)
    else:
        x = ""
    print(x)
    return x,transformer
        
def execute_a_phrase(phrase,parser,transformer,data):
    """Execute the provided phrase and return the result"""
    x,t = process_a_phrase(phrase,parser,transformer)
    exec(x,globals())
    catobj = CategoryObject(data,transformer.target_cat,transformer.dic)
    p = [myfunc(data,transformer.dic,p) for p in catobj]
    return p

class TestGrammar(object):
    def test_sum(self,lark_grammar,pytransformer):
        v = execute_a_phrase("return.val=1+2",lark_grammar,pytransformer,{})
        assert v == [3]

    def test_list(self,lark_grammar,pytransformer):
        v = execute_a_phrase("c=[1,2,3,4] return.val=c[0]+c[2]",lark_grammar,pytransformer,{})
        assert v == [4]

    def test_matrix(self,lark_grammar,pytransformer):
        v = execute_a_phrase(frag_collection["matrix"],lark_grammar,pytransformer,{})
        assert v[0][0][1] == 12

    def test_brackets(self,lark_grammar,pytransformer):
        process_a_phrase(frag_collection["brackets"],lark_grammar,pytransformer)

    def test_assign(self,lark_grammar,pytransformer):
        process_a_phrase(frag_collection["assign"],lark_grammar,pytransformer)

    def test_small_stmt(self,lark_grammar,pytransformer):
        """Test that a small statement after an IF statement is
        considered to be a suite"""
        process_a_phrase(frag_collection["call_suite"],lark_grammar)

    def test_ifelse_stmt(self,lark_grammar,pytransformer):
        """Test that ifelse is parsed correctly"""
        v = execute_a_phrase(frag_collection["ifelse"],lark_grammar,pytransformer,{})
        assert v[0] == 2

    def test_indices(self,lark_grammar,pytransformer):
        """Test that indices are selected correctly"""
        v = execute_a_phrase(frag_collection["indices"],lark_grammar,pytransformer,{})
        assert False
        
    def test_subs(self,lark_grammar,pytransformer):
        process_a_phrase("c[0]",lark_grammar,pytransformer)

class TestGrammarWithDic(object):
    """Test methods that require knowledge of the dictionary"""
    def py_t_dic(self,dataname,cifdic):
        """A transformer with dictionary knowledge"""
        tt = TreeToPy(dataname,"myfunc",cifdic)
        return tt
                  
    def test_ids(self,lark_grammar,load_cifdic):
        """Test that we can collect identifiers"""
        phrase = """
        _exptl_crystal.density_diffrn = 1.6605 * _cell.atomic_mass / _cell.volume
        """
        pt = self.py_t_dic("_exptl_crystal.density_diffrn",load_cifdic)
        _,t = process_a_phrase(phrase,lark_grammar,pt)
        assert 'cell' in t.cat_ids
        assert 'exptl_crystal' not in t.cat_ids #is the target

    def test_funcs(self,lark_grammar,load_cifdic):
        """Test that a function is defined correctly"""
        func_text = load_cifdic['_function.AtomType']
        func_text = func_text['_method.expression'][0]
        pt = TreeToPy('_function.AtomType','',load_cifdic)
        x,_ = process_a_phrase(func_text,lark_grammar,pt)
        exec(x,globals())
        assert AtomType('Fe3+_21') == 'Fe3+'
        assert AtomType('C22') == 'C'

    def test_SJ(self,lark_grammar,load_cifdic):
        """Test the complicated Seitz-Jones function"""
        import numpy
        func_text = load_cifdic['_function.SeitzFromJones']
        func_text = func_text['_method.expression'][0]
        pt = TreeToPy('_function.SeitzFromJones','',load_cifdic)
        x,_ = process_a_phrase(func_text,lark_grammar,pt)
        exec(x,globals())
        t = SeitzFromJones('1/2-x,1/2+y,-z')
        assert (t == numpy.matrix([[-1,0,0,0.5],
                                  [0,1,0,0.5],
                                  [0,0,-1,0],
                                  [0,0,0,1]])).all()

class TestDRELFuncs(object):
    """Test that Drel functions are recognised"""
    def test_numincell(self,load_funcs,getexecdata,load_cifdic):
        for f in load_funcs:
            exec(f,globals())
        olddata = getexecdata['_atom_type.number_in_cell']
        del getexecdata.datablock['_atom_type.number_in_cell']
        getexecdata.switch_drel()
        r = getexecdata['_atom_type.number_in_cell']
        assert list(map(float,olddata))[:2] == r[:2] #H atoms missing

    def test_sgsr(self,load_funcs,getexecdata,load_cifdic):
        for f in load_funcs:
            exec(f,globals())
        #olddata = getexecdata['_atom_type.number_in_cell']
        #del getexecdata.datablock['_atom_type.number_in_cell']
        getexecdata.switch_drel()
        r = getexecdata['_space_group_symop.R']
        print(r)
        assert len(r[1])==3

    def test_density(self,load_funcs,getexecdata,load_cifdic):
        for f in load_funcs:
            exec(f,globals())
        olddata = getexecdata['_exptl_crystal.density_diffrn']
        del getexecdata.datablock['_exptl_crystal.density_diffrn']
        getexecdata.switch_drel()
        r = getexecdata['_exptl_crystal.density_diffrn']
        assert abs(r - float(olddata)) < 0.001 #H atoms missing


class TestHelpers(object):
    """Test extra objects"""
    def test_catobj(self,load_cifdic,getdata):
        c = CategoryObject(getdata,"atom_site",load_cifdic)
        print(str(c))
        assert c[{'':'o3'}].fract_x == '.2501(5)'

    def test_iteration(self,load_cifdic,getdata):
        c = CategoryObject(getdata,"atom_site",load_cifdic)
        vals = set([c.fract_y for c in c])
        assert set(getdata['_atom_site.fract_y']) == vals

    def test_set_iteration(self,load_cifdic,getdata):
        c = CategoryObject(getdata,"cell",load_cifdic)
        vals = [c.volume for c in c]
        assert vals == ['635.3(11)']
        
    def test_packet(self,load_cifdic,getdata):
        af = lambda s:s
        p = Packet(af)
        assert p.stuff == "stuff"

    def test_multi_key(self,load_cifdic,getdata):
        """Test categories with more than one key data name"""
        c = CategoryObject(getdata,"geom_bond",load_cifdic)
        assert c[{'atom_site_label_1':'C1A',
                  'atom_site_label_2':'C10A',
                  'site_symmetry_1':'.',
                  'site_symmetry_2':'.'}].distance == '1.555(4)'

    def test_multi_iter(self,load_cifdic,getdata):
        """Test iterating categories with more than one key data name"""
        c = CategoryObject(getdata,"geom_bond",load_cifdic)
        vals = set([c.distance for c in c])
        assert set(getdata['_geom_bond.distance']) == vals
        
    def test_non_loop(self,load_cifdic,getdata):
        """Test that attributes for non-looped categories also work"""
        c = CategoryObject(getdata,"cell",load_cifdic)
        assert c.angle_beta == '90.8331(5)'

    def test_dodgy_iter(self,load_cifdic,getdata,load_funcs):
        """Recreate a test case"""
        for f in load_funcs:
            exec(f,globals())
        sg = CategoryObject(getdata,"space_group_symop",load_cifdic)
        c = CategoryObject(getdata,"space_group_symop",load_cifdic)
        for s in c:
            print(s.__current_row())
            sxyz = s.operation_xyz
        assert False
        
class TestExecBlock(object):
    def test_namespace(self,getexecdata):
        """Test that built-in functions are present"""
        assert 'AtomType' in getexecdata.namespace
        
    def test_set_calcs(self,getexecdata):
        """Test that we can perform single-packet calculations"""
        olddata = getexecdata['_exptl_crystal.density_diffrn']
        del getexecdata.datablock['_exptl_crystal.density_diffrn']
        getexecdata.switch_drel()
        r = getexecdata['_exptl_crystal.density_diffrn']
        assert abs(r - float(olddata)) < 0.0001

    def test_loop_calcs(self,getexecdata):
        """Test that we can perform multi-packet calculations"""
        olddata = getexecdata['_atom_type.number_in_cell']
        del getexecdata.datablock['_atom_type.number_in_cell']
        getexecdata.switch_drel()
        r = getexecdata['_atom_type.number_in_cell']
        print(r)
        assert False

    def test_missing_key(self,getexecdata):
        """Test that categories with missing keys are handled"""
        import sys
        sys.setrecursionlimit = 20
        getexecdata.switch_drel()
        r = getexecdata['_space_group_symop.id']
        assert set(r) == set([1,2,3,4])
 
class TestFullDic(object):
    """Test that we can parse a full dictionary"""
    def test_dic_entries(self,drel_methods,lark_grammar):
        for mn,(name,one_m) in enumerate(drel_methods):
            for n,om in enumerate(one_m):   #multiple methods possible
                print("=== %s(%d) ===" % (name,mn))
                print(om)
                tokens = lark_grammar.lex(om+"\n")
                for t in tokens:
                    print(repr(t))
                tree = lark_grammar.parse(om+"\n")
                print(tree.pretty())

    def test_python_code(self,drel_methods,lark_grammar):
        for mn,(name,one_m) in enumerate(drel_methods):
            for n,om in enumerate(one_m):
               pass
